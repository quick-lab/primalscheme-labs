<script>
	import ResultsRow from './ResultsRow.svelte';
	import { goto } from '$app/navigation';
	import { page } from '$app/stores';
	import { onMount } from 'svelte';
	import { flattenedSchemeIndex } from '$lib/flattenedSchemes.js';
	import { base } from '$app/paths';

	import Fuse from 'fuse.js';

	import Pagination from './Pagination.svelte';
	import sort from 'plotly.js/lib/sort';

	// Initial state
	let flatSchemes = undefined;
	let schemesLoading = true;
	let schemesErrored = false;
	let query = '';
	let pageNum = 1;
	let fuse = undefined;
	let onSubmit = () => {};

	const fuseOptions = {
		isCaseSensitive: false,
		keys: ['schemename', 'authors', 'description'],
		ignoreLocation: true,
		threshold: 0.3
	};

	// Set the filter checkbox values
	let showStatus = {
		withdrawn: false,
		deprecated: false,
		draft: true,
		autogenerated: true,
		tested: true,
		validated: true
	};

	onMount(async function () {
		query = $page.url.searchParams.get('q') || '';
		pageNum = $page.url.searchParams.get('pageNum') || 1;

		// Load schemes
		try {
			const response = await fetch(
				'https://raw.githubusercontent.com/quick-lab/primerschemes/main/index.json?token=GHSAT0AAAAAACNCOBUYYT5TX3KGXDHSVOQYZNKMMFA'
			);
			const schemes = await response.json();
			flatSchemes = flattenedSchemeIndex(schemes);
		} catch (err) {
			console.log(err);
			schemesErrored = true;
		} finally {
			schemesLoading = false;
		}

		fuse = new Fuse(flatSchemes, fuseOptions);
	});

	$: flatSearchResult = query.trim().length
		? fuse?.search(query)
		: flatSchemes?.map((item, index) => ({
				item,
				refIndex: index,
				matches: [],
				score: 1
		  }));

	// Pages
	const pageSize = 25;
	$: pageIndex = pageNum - 1;
	$: pageCount = Math.ceil(flatSearchResult?.length / pageSize);

	$: filteredFlatSearchResult = flatSearchResult?.filter((item) => {
		return showStatus[item.item.status];
	});

	$: searchResult = filteredFlatSearchResult?.slice(
		pageIndex * pageSize,
		pageIndex * pageSize + pageSize
	);

	let timer;
	const debouncedSubmit = async () => {
		clearTimeout(timer);
		timer = setTimeout(onSubmit, 250);
	};

	$: if (pageNum > pageCount) {
		pageNum = Math.max(pageCount, 1);
	}

	onSubmit = async () => {
		let navSearchQuery = $page.url.searchParams.get('q') || '';
		let navPageNum = $page.url.searchParams.get('pageNum') || 1;

		if (query.trim() == navSearchQuery.trim() && pageNum == navPageNum.trim())
			// don't navigate if the query is the same
			return;

		await goto(
			query.trim().length
				? `${base}/?q=${encodeURIComponent(query.trim())}&pageNum=${pageNum}`
				: `${base}/?pageNum=${pageNum}`,
			{
				keepFocus: true
			}
		);
	};
</script>

{#if schemesLoading}
	<p aria-busy="true">Loading data...</p>
{:else if schemesErrored}
	<p>Unable to load schemes data...</p>
{:else}
	<form id="search form" on:submit|preventDefault={onSubmit}>
		<input type="text" placeholder="Search..." bind:value={query} on:keyup={debouncedSubmit} />

		<details open>
			<summary>Advanced Search</summary>
			<fieldset role="group">
				<div>
					<legend>Status</legend>
					{#each Object.entries(showStatus) as [status, value]}
						<label>
							<input
								type="checkbox"
								role="switch"
								bind:checked={showStatus[status]}
								aria-invalid="false"
							/>
							Show {status}
						</label>
					{/each}
				</div>
			</fieldset>
		</details>
	</form>

	<hr />

	{#if searchResult.length > 0}
		<table>
			<tbody>
				{#each searchResult as result}
					<ResultsRow scheme={result.item} {query} />
				{/each}
			</tbody>
		</table>
	{:else}
		<p>No results</p>
	{/if}
	<Pagination
		{pageCount}
		{pageNum}
		resultCount={filteredFlatSearchResult.length}
		pageSize={searchResult.length}
		{query}
	/>
{/if}

<style>
	form {
		margin-bottom: 2rem;
	}

	details {
		color: var(--pico-primary);
	}
	label:hover {
		color: var(--pico-secondary);
	}
</style>
