<script>
	import ResultsRow from './ResultsRow.svelte';
	import { goto } from '$app/navigation';
	import { page } from '$app/stores';
	import { onMount } from 'svelte';
	import { flattenedSchemeIndex } from '$lib/flattenedSchemes.js';
	import { base } from '$app/paths';

	import Fuse from 'fuse.js';

	import Pagination from './Pagination.svelte';

	// Initial state
	let flatSchemes = undefined;
	let schemesLoading = true;
	let schemesErrored = false;
	let query = '';
	let pageNum = 1;
	let fuse = undefined;
	let onSubmit = () => {};

	const fuseOptions = {
		isCaseSensitive: false,
		keys: ['schemename', 'authors', 'description'],
		ignoreLocation: true,
		threshold: 0.3
	};

	// Set the filter checkbox values
	let showStatus = {
		withdrawn: false,
		deprecated: false,
		draft: true,
		autogenerated: true,
		tested: true,
		validated: true
	};

	// Get the collection names
	let collections = {};

	// filter function
	const filterFunction = (scheme, statusObj, collectionObj) => {
		// Filter by status
		if (!statusObj[scheme.status]) return false;

		// Filter by collection
		if (
			Object.entries(collectionObj).some(
				([collection, value]) => value && !scheme.collections.includes(collection)
			)
		)
			return false;
		return true;
	};

	onMount(async function () {
		query = $page.url.searchParams.get('q') || '';
		pageNum = $page.url.searchParams.get('pageNum') || 1;

		// Load schemes
		try {
			const response = await fetch(
				'https://raw.githubusercontent.com/quick-lab/primerschemes/main/index.json?token=GHSAT0AAAAAACNCOBUYYT5TX3KGXDHSVOQYZNKMMFA'
			);
			const schemes = await response.json();
			flatSchemes = flattenedSchemeIndex(schemes);
		} catch (err) {
			console.log(err);
			schemesErrored = true;
		} finally {
			schemesLoading = false;
		}

		fuse = new Fuse(flatSchemes, fuseOptions);
	});

	$: flatSearchResult = query.trim().length
		? fuse?.search(query)
		: flatSchemes?.map((item, index) => ({
				item,
				refIndex: index,
				matches: [],
				score: 1
		  }));

	// Get the collection names
	$: {
		let _a = [
			...new Set(
				flatSchemes?.reduce((acc, scheme) => {
					acc.push(...scheme?.collections);
					return acc;
				}, [])
			)
		].sort();
		_a.forEach((collection) => {
			if (collections[collection] === undefined) {
				collections[collection] = false;
			}
		});
	}

	// Pages
	const pageSize = 25;
	$: pageIndex = pageNum - 1;
	$: pageCount = Math.ceil(flatSearchResult?.length / pageSize);

	// Filter the search results
	$: filteredFlatSearchResult = flatSearchResult?.filter((item) => {
		return filterFunction(item.item, showStatus, collections);
	});

	$: searchResult = filteredFlatSearchResult?.slice(
		pageIndex * pageSize,
		pageIndex * pageSize + pageSize
	);

	let timer;
	const debouncedSubmit = async () => {
		clearTimeout(timer);
		timer = setTimeout(onSubmit, 250);
	};

	$: if (pageNum > pageCount) {
		pageNum = Math.max(pageCount, 1);
	}

	onSubmit = async () => {
		let navSearchQuery = $page.url.searchParams.get('q') || '';
		let navPageNum = $page.url.searchParams.get('pageNum') || 1;

		if (query.trim() == navSearchQuery.trim() && pageNum == navPageNum.trim())
			// don't navigate if the query is the same
			return;

		await goto(
			query.trim().length
				? `${base}/?q=${encodeURIComponent(query.trim())}&pageNum=${pageNum}`
				: `${base}/?pageNum=${pageNum}`,
			{
				keepFocus: true
			}
		);
	};
</script>

{#if schemesLoading}
	<p aria-busy="true">Loading data...</p>
{:else if schemesErrored}
	<p>Unable to load schemes data...</p>
{:else}
	<form id="search form" on:submit|preventDefault={onSubmit}>
		<input type="text" placeholder="Search..." bind:value={query} on:keyup={debouncedSubmit} />

		<details open>
			<summary><h5>Advanced Search</h5></summary>
			<fieldset>
				<div class="grid">
					<!-- Status filter -->
					<div>
						<legend><h6>Status</h6></legend>
						{#each Object.entries(showStatus) as [status, value]}
							<label>
								<input
									type="checkbox"
									role="switch"
									bind:checked={showStatus[status]}
									aria-invalid="false"
								/>
								Show {status}
							</label>
						{/each}
					</div>
					<!-- Collection filter -->
					<div>
						<legend><h6>Collection</h6></legend>
						<div>
							{#each Object.entries(collections) as [collection, value]}
								{#if value}
									<button
										class="collectionbutton"
										on:click={() => (collections[collection] = !collections[collection])}
										>{collection}</button
									>
								{:else}
									<button
										class="collectionbutton outline"
										on:click={() => (collections[collection] = !collections[collection])}
										>{collection}</button
									>
								{/if}
							{/each}
						</div>
					</div>
				</div>
			</fieldset>
		</details>
	</form>

	<hr />

	{#if searchResult.length > 0}
		<table>
			<tbody>
				{#each searchResult as result}
					<ResultsRow scheme={result.item} {query} />
				{/each}
			</tbody>
		</table>
	{:else}
		<p>No results</p>
	{/if}
	<Pagination
		{pageCount}
		{pageNum}
		resultCount={filteredFlatSearchResult.length}
		pageSize={searchResult.length}
		{query}
	/>
{/if}

<style>
	form {
		margin-bottom: 2rem;
	}
	button.collectionbutton {
		margin: 0.2em;
	}

	details {
		color: var(--pico-primary);
	}
	label:hover {
		color: var(--pico-secondary);
	}
</style>
